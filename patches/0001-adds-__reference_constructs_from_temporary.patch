From 9dd54c6a24da2eb481f4134b91a1d10bba1ca329 Mon Sep 17 00:00:00 2001
From: Christopher Di Bella <cjdb.ns@gmail.com>
Date: Sat, 22 Oct 2022 22:54:38 -0700
Subject: [PATCH 1/3] adds `__reference_constructs_from_temporary`

This is information that the compiler already has, and should be exposed
so that the library doesn't need to reimplement the exact same
functionality.

Differential Revision: https://reviews.llvm.org/D135341
---
 clang/docs/LanguageExtensions.rst             |   1 +
 .../clang/Basic/DiagnosticCommonKinds.td      |   3 +
 clang/include/clang/Basic/TokenKinds.def      |   2 +
 clang/lib/Lex/PPMacroExpansion.cpp            |   2 +
 clang/lib/Parse/ParseDeclCXX.cpp              |   5 +-
 clang/lib/Parse/ParseExpr.cpp                 |   3 +
 clang/lib/Sema/SemaExprCXX.cpp                |  28 ++-
 clang/test/SemaCXX/type-traits.cpp            |  49 +++++
 clang/www/cxx_status.html                     | 191 ++++++++++++++++++
 9 files changed, 278 insertions(+), 6 deletions(-)

diff --git a/clang/docs/LanguageExtensions.rst b/clang/docs/LanguageExtensions.rst
index 38a73f310648..38e38797df35 100644
--- a/clang/docs/LanguageExtensions.rst
+++ b/clang/docs/LanguageExtensions.rst
@@ -1614,6 +1614,7 @@ The following type trait primitives are supported by Clang. Those traits marked
   materialized temporary object. If ``T`` is not a reference type the result
   is false. Note this trait will also return false when the initialization of
   ``T`` from ``U`` is ill-formed.
+* ``__reference_constructs_from_temporary(T, U)`` (C++)
 * ``__underlying_type`` (C++, GNU, Microsoft)
 
 In addition, the following expression traits are supported:
diff --git a/clang/include/clang/Basic/DiagnosticCommonKinds.td b/clang/include/clang/Basic/DiagnosticCommonKinds.td
index ee994e765e09..0e0d27795266 100644
--- a/clang/include/clang/Basic/DiagnosticCommonKinds.td
+++ b/clang/include/clang/Basic/DiagnosticCommonKinds.td
@@ -421,4 +421,7 @@ def err_opencl_extension_and_feature_differs : Error<
   "options %0 and %1 are set to different values">;
 def err_opencl_feature_requires : Error<
   "feature %0 requires support of %1 feature">;
+
+def err_reserved_identifier_for_future_use : Error<
+  "%0 is a compiler-reserved identifier for a future feature">;
 }
diff --git a/clang/include/clang/Basic/TokenKinds.def b/clang/include/clang/Basic/TokenKinds.def
index ef0dad0f2dcd..c5a23949430a 100644
--- a/clang/include/clang/Basic/TokenKinds.def
+++ b/clang/include/clang/Basic/TokenKinds.def
@@ -531,6 +531,8 @@ TYPE_TRAIT_1(__is_scoped_enum, IsScopedEnum, KEYCXX)
 TYPE_TRAIT_1(__is_referenceable, IsReferenceable, KEYCXX)
 TYPE_TRAIT_1(__can_pass_in_regs, CanPassInRegs, KEYCXX)
 TYPE_TRAIT_2(__reference_binds_to_temporary, ReferenceBindsToTemporary, KEYCXX)
+TYPE_TRAIT_2(__reference_constructs_from_temporary, ReferenceConstructsFromTemporary, KEYCXX)
+TYPE_TRAIT_2(__reference_converts_from_temporary, ReferenceConvertsFromTemporary, KEYCXX)
 
 // Embarcadero Expression Traits
 EXPRESSION_TRAIT(__is_lvalue_expr, IsLValueExpr, KEYCXX)
diff --git a/clang/lib/Lex/PPMacroExpansion.cpp b/clang/lib/Lex/PPMacroExpansion.cpp
index a14fdcda58e0..d75f1fa9ec4c 100644
--- a/clang/lib/Lex/PPMacroExpansion.cpp
+++ b/clang/lib/Lex/PPMacroExpansion.cpp
@@ -1695,6 +1695,8 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {
               .Case("__array_rank", true)
               .Case("__array_extent", true)
               .Case("__reference_binds_to_temporary", true)
+              .Case("__reference_constructs_from_temporary", true)
+              .Case("__reference_converts_from_temporary", true)
 #define TRANSFORM_TYPE_TRAIT_DEF(_, Trait) .Case("__" #Trait, true)
 #include "clang/Basic/TransformTypeTraits.def"
               .Default(false);
diff --git a/clang/lib/Parse/ParseDeclCXX.cpp b/clang/lib/Parse/ParseDeclCXX.cpp
index eacb4fa23434..d5d469c8b743 100644
--- a/clang/lib/Parse/ParseDeclCXX.cpp
+++ b/clang/lib/Parse/ParseDeclCXX.cpp
@@ -1638,7 +1638,10 @@ void Parser::ParseClassSpecifier(tok::TokenKind TagTokKind,
           tok::kw___is_union,
           tok::kw___is_unsigned,
           tok::kw___is_void,
-          tok::kw___is_volatile))
+          tok::kw___is_volatile,
+          tok::kw___reference_binds_to_temporary,
+          tok::kw___reference_constructs_from_temporary,
+          tok::kw___reference_converts_from_temporary))
     // GNU libstdc++ 4.2 and libc++ use certain intrinsic names as the
     // name of struct templates, but some are keywords in GCC >= 4.3
     // and Clang. Therefore, when we see the token sequence "struct
diff --git a/clang/lib/Parse/ParseExpr.cpp b/clang/lib/Parse/ParseExpr.cpp
index 179657fc1ed1..d5ef98c4e621 100644
--- a/clang/lib/Parse/ParseExpr.cpp
+++ b/clang/lib/Parse/ParseExpr.cpp
@@ -1127,6 +1127,9 @@ ExprResult Parser::ParseCastExpression(CastParseKind ParseKind,
           REVERTIBLE_TYPE_TRAIT(__is_unsigned);
           REVERTIBLE_TYPE_TRAIT(__is_void);
           REVERTIBLE_TYPE_TRAIT(__is_volatile);
+          REVERTIBLE_TYPE_TRAIT(__reference_binds_to_temporary);
+          REVERTIBLE_TYPE_TRAIT(__reference_constructs_from_temporary);
+          REVERTIBLE_TYPE_TRAIT(__reference_converts_from_temporary);
 #define TRANSFORM_TYPE_TRAIT_DEF(_, Trait)                                     \
   REVERTIBLE_TYPE_TRAIT(RTT_JOIN(__, Trait));
 #include "clang/Basic/TransformTypeTraits.def"
diff --git a/clang/lib/Sema/SemaExprCXX.cpp b/clang/lib/Sema/SemaExprCXX.cpp
index 4d05a0e0c507..478947b79656 100644
--- a/clang/lib/Sema/SemaExprCXX.cpp
+++ b/clang/lib/Sema/SemaExprCXX.cpp
@@ -29,6 +29,7 @@
 #include "clang/Basic/TargetInfo.h"
 #include "clang/Basic/TokenKinds.h"
 #include "clang/Basic/TypeTraits.h"
+#include "clang/Basic/TokenKinds.h"
 #include "clang/Lex/Preprocessor.h"
 #include "clang/Sema/DeclSpec.h"
 #include "clang/Sema/EnterExpressionEvaluationContext.h"
@@ -5404,14 +5405,15 @@ static bool EvaluateBooleanTypeTrait(Sema &S, TypeTrait Kind,
   if (Kind <= UTT_Last)
     return EvaluateUnaryTypeTrait(S, Kind, KWLoc, Args[0]->getType());
 
-  // Evaluate BTT_ReferenceBindsToTemporary alongside the IsConstructible
-  // traits to avoid duplication.
-  if (Kind <= BTT_Last && Kind != BTT_ReferenceBindsToTemporary)
+  // Evaluate ReferenceBindsToTemporary and ReferenceConstructsFromTemporary
+  // alongside the IsConstructible traits to avoid duplication.
+  if (Kind <= BTT_Last && Kind != BTT_ReferenceBindsToTemporary && Kind != BTT_ReferenceConstructsFromTemporary)
     return EvaluateBinaryTypeTrait(S, Kind, Args[0]->getType(),
                                    Args[1]->getType(), RParenLoc);
 
   switch (Kind) {
   case clang::BTT_ReferenceBindsToTemporary:
+  case clang::BTT_ReferenceConstructsFromTemporary:
   case clang::TT_IsConstructible:
   case clang::TT_IsNothrowConstructible:
   case clang::TT_IsTriviallyConstructible: {
@@ -5488,11 +5490,23 @@ static bool EvaluateBooleanTypeTrait(Sema &S, TypeTrait Kind,
     if (Kind == clang::TT_IsConstructible)
       return true;
 
-    if (Kind == clang::BTT_ReferenceBindsToTemporary) {
+    if (Kind == clang::BTT_ReferenceBindsToTemporary || Kind == clang::BTT_ReferenceConstructsFromTemporary) {
       if (!T->isReferenceType())
         return false;
 
-      return !Init.isDirectReferenceBinding();
+      if (!Init.isDirectReferenceBinding())
+        return true;
+
+      if (Kind == clang::BTT_ReferenceBindsToTemporary)
+        return false;
+
+      QualType U = Args[1]->getType();
+      if (U->isReferenceType())
+        return false;
+
+      QualType TPtr = S.BuiltinAddPointer(S.BuiltinRemoveReference(T, UnaryTransformType::RemoveCVRef, {}), {});
+      QualType UPtr = S.BuiltinAddPointer(S.BuiltinRemoveReference(U, UnaryTransformType::RemoveCVRef, {}), {});
+      return EvaluateBinaryTypeTrait(S, TypeTrait::BTT_IsConvertibleTo, UPtr, TPtr, RParenLoc);
     }
 
     if (Kind == clang::TT_IsNothrowConstructible)
@@ -5690,6 +5704,10 @@ static bool EvaluateBinaryTypeTrait(Sema &Self, TypeTrait BTT, QualType LhsT,
     QualType Rhs = Self.getASTContext().getUnqualifiedArrayType(RhsT, RhsQuals);
     return Self.Context.typesAreCompatible(Lhs, Rhs);
   }
+  case BTT_ReferenceConvertsFromTemporary: {
+    std::string Spelling = "'" + std::string(getTraitSpelling(BTT)) + "'";
+    return Self.Diag(KeyLoc, diag::err_reserved_identifier_for_future_use) << Spelling;
+  }
   case BTT_IsConvertible:
   case BTT_IsConvertibleTo: {
     // C++0x [meta.rel]p4:
diff --git a/clang/test/SemaCXX/type-traits.cpp b/clang/test/SemaCXX/type-traits.cpp
index ba52ca748fed..e702e9aa5aac 100644
--- a/clang/test/SemaCXX/type-traits.cpp
+++ b/clang/test/SemaCXX/type-traits.cpp
@@ -2542,6 +2542,55 @@ void reference_binds_to_temporary_checks() {
   { int arr[T((__reference_binds_to_temporary(const int &, long)))]; }
 }
 
+void reference_constructs_from_temporary_checks() {
+  static_assert(!__reference_constructs_from_temporary(int &, int &), "");
+  static_assert(!__reference_constructs_from_temporary(int &, int &&), "");
+
+  static_assert(!__reference_constructs_from_temporary(int const &, int &), "");
+  static_assert(!__reference_constructs_from_temporary(int const &, int const &), "");
+  static_assert(!__reference_constructs_from_temporary(int const &, int &&), "");
+
+  static_assert(!__reference_constructs_from_temporary(int &, long &), ""); // doesn't construct
+
+  static_assert(__reference_constructs_from_temporary(int const &, long &), "");
+  static_assert(__reference_constructs_from_temporary(int const &, long &&), "");
+  static_assert(__reference_constructs_from_temporary(int &&, long &), "");
+
+  using LRef = ConvertsToRef<int, int &>;
+  using RRef = ConvertsToRef<int, int &&>;
+  using CLRef = ConvertsToRef<int, const int &>;
+  using LongRef = ConvertsToRef<long, long &>;
+  static_assert(__is_constructible(int &, LRef), "");
+  static_assert(!__reference_constructs_from_temporary(int &, LRef), "");
+
+  static_assert(__is_constructible(int &&, RRef), "");
+  static_assert(!__reference_constructs_from_temporary(int &&, RRef), "");
+
+  static_assert(__is_constructible(int const &, CLRef), "");
+  static_assert(!__reference_constructs_from_temporary(int &&, CLRef), "");
+
+  static_assert(__is_constructible(int const &, LongRef), "");
+  static_assert(__reference_constructs_from_temporary(int const &, LongRef), "");
+
+  // Test that it doesn't accept non-reference types as input.
+  static_assert(!__reference_constructs_from_temporary(int, long), "");
+
+  static_assert(__reference_constructs_from_temporary(const int &, long), "");
+
+  // Additional checks
+  static_assert(__reference_constructs_from_temporary(POD const&, Derives), "");
+  static_assert(__reference_constructs_from_temporary(int&&, int), "");
+  static_assert(__reference_constructs_from_temporary(const int&, int), "");
+  static_assert(!__reference_constructs_from_temporary(int&&, int&&), "");
+  static_assert(!__reference_constructs_from_temporary(const int&, int&&), "");
+  static_assert(__reference_constructs_from_temporary(int&&, long&&), "");
+  static_assert(__reference_constructs_from_temporary(int&&, long), "");
+}
+
+void reference_converts_from_temporary() {
+  (void)__reference_converts_from_temporary(int, int); // expected-error{{'__reference_converts_from_temporary' is a compiler-reserved identifier for a future feature}}
+}
+
 void array_rank() {
   int t01[T(__array_rank(IntAr) == 1)];
   int t02[T(__array_rank(ConstIntArAr) == 2)];
diff --git a/clang/www/cxx_status.html b/clang/www/cxx_status.html
index 2c98f86c09a9..75c13874374a 100755
--- a/clang/www/cxx_status.html
+++ b/clang/www/cxx_status.html
@@ -1091,6 +1091,197 @@ You can use Clang in C++17 mode with the <code>-std=c++17</code> option
       <td><a href="https://wg21.link/p0195r2">P0195R2</a></td>
       <td class="full" align="center">Clang 4</td>
     </tr>
+      <td rowspan=2>Change scope of lambda trailing-return-type</td>
+      <td><a href="https://wg21.link/P2036R3">P2036R3</a></td>
+      <td rowspan=2 class="unreleased" align="center">Clang 17</td>
+    </tr>
+    <tr>
+      <td><a href="https://wg21.link/P2579R0">P2579R0</a></td>
+    </tr>
+    <tr>
+      <td>Multidimensional subscript operator</td>
+      <td><a href="https://wg21.link/P2128R6">P2128R6</a></td>
+      <td class="full" align="center">Clang 15</td>
+    </tr>
+    <tr>
+      <td>Non-literal variables (and labels and gotos) in constexpr functions</td>
+      <td><a href="https://wg21.link/P2242R3">P2242R3</a></td>
+      <td class="full" align="center">Clang 15</td>
+    </tr>
+    <tr>
+      <td>Character encoding of diagnostic text</td>
+      <td><a href="https://wg21.link/P2246R1">P2246R1</a></td>
+      <td class="full" align="center">Yes</td>
+    </tr>
+    <tr>
+      <td>Character sets and encodings</td>
+      <td><a href="https://wg21.link/P2314R4">P2314R4</a></td>
+      <td class="full" align="center">Yes</td>
+    </tr>
+    <tr>
+      <td>Consistent character literal encoding</td>
+      <td><a href="https://wg21.link/P2316R2">P2316R2</a></td>
+      <td class="full" align="center">Yes</td>
+    </tr>
+    <tr>
+      <td>Add support for preprocessing directives elifdef and elifndef</td>
+      <td><a href="https://wg21.link/P2334R1">P2334R1</a></td>
+      <td class="full" align="center">Clang 13</td>
+    </tr>
+    <tr>
+      <td>Extend init-statement to allow alias-declaration</td>
+      <td><a href="https://wg21.link/P2360R0">P2360R0</a></td>
+      <td class="full" align="center">Clang 14</td>
+    </tr>
+    <tr>
+      <td>auto(x): decay-copy in the language</td>
+      <td><a href="https://wg21.link/P0849R8">P0849R8</a></td>
+      <td class="full" align="center">Clang 15</td>
+    </tr>
+    <!-- February 2022 papers -->
+    <tr>
+      <td>Attributes on Lambda-Expressions</td>
+      <td><a href="https://wg21.link/P2173R1">P2173R1</a></td>
+      <td class="full" align="center">Clang 13</td>
+    </tr>
+    <tr>
+      <td><tt>constexpr</tt> for <tt>&lt;cmath&gt;</tt> and <tt>&lt;cstdlib&gt;</tt></td>
+      <td><a href="https://wg21.link/P0533R9">P0533R9</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <tr>
+      <td>Type trait to determine if a reference binds to a temporary</td>
+      <td><a href="https://wg21.link/P2255R2">P2255R2</a></td>
+      <td class="partial" align="center">
+        <details><summary>Partial</summary>
+          Clang provides <tt>__reference_constructs_from_temporary</tt> type
+          trait builtin, with which <tt>std::reference_constructs_from_temporary</tt>
+          implemented. <tt>__reference_converts_from_temporary</tt> needs to be
+          provided, following the normal cross-vendor convention to implement
+          traits requiring compiler support directly.
+        </details></td>
+      </td>
+    </tr>
+    <!-- July 2022 papers -->
+    <tr>
+      <td>The Equality Operator You Are Looking For</td>
+      <td><a href="https://wg21.link/P2468R2">P2468R2</a></td>
+      <td class="full" align="center">Clang 16</td>
+    </tr>
+    <tr>
+      <td>De-deprecating volatile compound operations</td>
+      <td><a href="https://wg21.link/P2327R1">P2327R1</a></td>
+      <td class="full" align="center">Clang 15</td>
+    </tr>
+    <tr>
+      <td>Support for <code>#warning</code></td>
+      <td><a href="https://wg21.link/P2437R1">P2437R1</a></td>
+      <td class="full" align="center">Yes</td>
+    </tr>
+    <tr>
+      <td>Remove non-encodable wide character literals and multicharacter wide character literals</td>
+      <td><a href="https://wg21.link/P2362R3">P2362R3</a></td>
+      <td class="full" align="center">Clang 14</td>
+    </tr>
+    <tr>
+      <td>Labels at the end of compound statements</td>
+      <td><a href="https://wg21.link/P2324R2">P2324R2</a></td>
+      <td class="full" align="center">Clang 16</td>
+    </tr>
+    <tr>
+      <td>Delimited escape sequences</td>
+      <td><a href="https://wg21.link/P2290R3">P2290R3</a></td>
+      <td class="full" align="center">Clang 15</td>
+    </tr>
+    <tr>
+      <td>Named universal character escapes</td>
+      <td><a href="https://wg21.link/P2071R2">P2071R2</a></td>
+      <td class="full" align="center">Clang 15</td>
+    </tr>
+    <tr>
+      <td>Relaxing some constexpr restrictions</td>
+      <td><a href="https://wg21.link/P2448R2">P2448R2</a></td>
+      <td class="partial" align="center">
+        <details><summary>Clang 17 (Partial)</summary>
+	  We do not support outside of defaulted special memeber functions the change that constexpr functions no
+          longer have to be constexpr compatible but rather support a less restricted requirements for constexpr
+          functions. Which include allowing non-literal types as return values and paremeters, allow calling of
+          non-constexpr functions and constructors.
+        </details></td>
+      </td>
+    </tr>
+    <tr>
+      <td>Using unknown pointers and references in constant expressions</td>
+      <td><a href="https://wg21.link/P2280R4">P2280R4</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <tr>
+      <td>static <code>operator()</code></td>
+      <td><a href="https://wg21.link/P1169R4">P1169R4</a></td>
+      <td class="full" align="center">Clang 16</td>
+    </tr>
+    <tr>
+      <td>Extended floating-point types and standard names</td>
+      <td><a href="https://wg21.link/P1467R9">P1467R9</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <tr>
+      <td>Class template argument deduction from inherited constructors</td>
+      <td><a href="https://wg21.link/P2582R1">P2582R1</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <tr>
+      <td>Portable assumptions</td>
+      <td><a href="https://wg21.link/P1774R8">P1774R8</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <tr>
+      <td>Support for UTF-8 as a portable source file encoding</td>
+      <td><a href="https://wg21.link/P2295R6">P2295R6</a></td>
+      <td class="full" align="center">Clang 15</td>
+    </tr>
+    <tr>
+      <td><code>char8_t</code> Compatibility and Portability Fix</td>
+      <td><a href="https://wg21.link/P2513R3">P2513R3</a></td>
+      <td class="full" align="center">Clang 16</td>
+    </tr>
+    <tr>
+      <td>Relax requirements on <code>wchar_t</code> to match existing practices</td>
+      <td><a href="https://wg21.link/P2460R2">P2460R2</a></td>
+      <td class="full" align="center">Yes</td>
+    </tr>
+    <tr>
+      <td>Explicit lifetime management</td>
+      <td><a href="https://wg21.link/P2590R2">P2590R2</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <!-- November 2022 (Kona) papers -->
+    <tr>
+      <td>static <code>operator[]</code></td>
+      <td><a href="https://wg21.link/P2589R1">P2589R1</a></td>
+      <td class="full" align="center">Clang 16</td>
+    </tr>
+    <tr>
+      <td>Permitting static constexpr variables in constexpr functions</td>
+      <td><a href="https://wg21.link/P2647R1">P2647R1</a></td>
+      <td class="full" align="center">Clang 16</td>
+    </tr>
+    <tr>
+      <td>consteval needs to propagate up</td>
+      <td><a href="https://wg21.link/P2564R3">P2564R3</a> (<a href="#dr">DR</a>)</td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <tr>
+      <td>Lifetime extension in range-based for loops</td>
+      <td><a href="https://wg21.link/P2718R0">P2718R0</a></td>
+      <td class="none" align="center">No</td>
+    </tr>
+    <!--Issaquah 2023 papers-->
+    <tr>
+      <td>Referencing The Unicode Standard</td>
+      <td><a href="https://wg21.link/P2736R2">P2736R2</a></td>
+      <td class="full" align="center">Yes</td>
+    </tr>
 </table>
 
 <p>
-- 
2.41.0

